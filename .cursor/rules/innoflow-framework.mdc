---
description: "InnoFlow 프레임워크의 아키텍처, 데이터 흐름, 매크로 확장, Store 기능, 테스트 패턴에 대한 종합 가이드. 프레임워크 코드 작업, 새로운 기능 추가, 또는 아키텍처 이해가 필요할 때 적용."
globs: ["Sources/**/*.swift"]
alwaysApply: false
---

# InnoFlow Framework Architecture

## 프로젝트 개요

InnoFlow는 SwiftUI를 위한 경량 하이브리드 아키텍처 프레임워크로, Elm Architecture와 Swift의 `@Observable` 패턴을 결합합니다. 최소한의 보일러플레이트로 단방향 데이터 흐름을 제공합니다.

## 모듈 구조

```
InnoFlow/
├── Sources/
│   ├── InnoFlow/              # 핵심 프레임워크
│   │   ├── InnoFlow.swift     # @InnoFlow 및 @BindableField 매크로
│   │   ├── Store.swift        # Store 및 ScopedStore 구현
│   │   ├── Reducer.swift      # Reducer 프로토콜
│   │   ├── Reduce.swift       # Reduce 결과 타입
│   │   └── EffectOutput.swift # Effect 출력 타입 (.none, .single, .stream)
│   ├── InnoFlowMacros/        # 매크로 구현 (swift-syntax 사용)
│   │   └── InnoFlowMacro.swift
│   └── InnoFlowTesting/       # 테스트 유틸리티
│       └── TestStore.swift
└── Tests/
    ├── InnoFlowTests/         # 핵심 프레임워크 테스트
    └── InnoFlowMacrosTests/   # 매크로 확장 테스트
```

## 데이터 흐름

1. **Action Dispatch**: View에서 `store.send(action)` 호출
2. **Reduce Phase**: `reduce(state:action:)`이 `Reduce<Mutation, Effect>` 반환
3. **Mutation Phase**: 각 mutation이 `mutate(state:mutation:)`을 통해 적용
4. **Effect Execution**: Effect가 비동기적으로 `handle(effect:)`를 통해 처리되며 `EffectOutput<Action>` 반환
5. **State Update**: Mutation이 state를 업데이트하고, `@Observable`을 통해 view 갱신 트리거

## Effect 출력 타입

Effect는 다음을 반환할 수 있습니다:
- `.none` - Fire-and-forget (분석, 로깅)
- `.single(action)` - 단일 action 응답 (API 호출에 가장 일반적)
- `.stream(AsyncStream<Action>)` - 시간에 따른 여러 action (WebSocket, 진행 업데이트)
- `.actions(action1, action2, ...)` - 여러 순차 action을 위한 편의 메서드

## 매크로 확장

### `@InnoFlow` 매크로:
- `extension FeatureName: Reducer {}` 추가
- `Effect` 타입이 정의되지 않은 경우: `typealias Effect = Never` 추가
- `Effect == Never`이고 `handle()`이 없는 경우: 기본 `handle(effect:)` 구현 추가

### `@BindableField` 매크로:
- `@BindableField var step = 1`을 다음으로 변환:
  - Private storage: `private var _step_storage = BindableProperty(1)`
  - Computed property with getter/setter accessing `.value`
- `@BindableField`로 표시된 속성만 `store.binding(_:send:)` 사용 가능

## Store 기능

- **Dynamic Member Lookup**: `store.count` 대신 `store.state.count` 사용 가능
- **Automatic Unwrapping**: `BindableProperty<T>` 값이 subscript를 통해 자동 언래핑
- **Thread Safety**: `Store`에 `@MainActor`, Mutex를 사용한 스레드 안전 effect task 저장
- **Scoping**: `store.scope(state:action:)`이 자식 view를 위한 `ScopedStore` 생성
- **Effect Lifecycle**: Effect는 `deinit` 시 또는 `cancelAllEffects()`를 통해 자동 취소

## 일반적인 패턴

### Effect 없는 Feature
```swift
@InnoFlow
struct CounterFeature {
    struct State: Equatable { var count = 0 }
    enum Action { case increment }
    enum Mutation { case setCount(Int) }

    func reduce(state: State, action: Action) -> Reduce<Mutation, Never> {
        .mutation(.setCount(state.count + 1))
    }

    func mutate(state: inout State, mutation: Mutation) {
        switch mutation { case .setCount(let v): state.count = v }
    }
}
```

### Effect 있는 Feature
```swift
@InnoFlow
struct UserFeature {
    struct State: Equatable { var user: User? }
    enum Action: Sendable { case load; case _loaded(User) }
    enum Mutation { case setUser(User?) }
    enum Effect: Sendable { case fetchUser }

    let api: APIClient

    func reduce(state: State, action: Action) -> Reduce<Mutation, Effect> {
        switch action {
        case .load: return .effect(.fetchUser)
        case ._loaded(let user): return .mutation(.setUser(user))
        }
    }

    func mutate(state: inout State, mutation: Mutation) {
        switch mutation { case .setUser(let u): state.user = u }
    }

    func handle(effect: Effect) async -> EffectOutput<Action> {
        switch effect {
        case .fetchUser:
            let user = try? await api.fetchUser()
            return .single(._loaded(user))
        }
    }
}
```

### Bindable Fields
```swift
struct State: Equatable {
    @BindableField var name = ""
    @BindableField var step = 1
    var count = 0  // Bindable 아님
}

// View에서:
TextField("Name", text: store.binding(\.name, send: { .nameChanged($0) }))
Stepper("Step", value: store.binding(\.step, send: { .setStep($0) }))
```

## 네이밍 규칙

- **Internal Actions**: `_` 접두사 사용 (예: `._loaded`, `._dataFetched`)
- **State**: `Equatable` 준수 필수, 선택적으로 `DefaultInitializable` 준수하여 `Store(feature)` init 사용 가능
- **Action/Effect**: 동시성 안전을 위해 `Sendable` 준수 권장
- **Mutation**: 순수 state 변환만, 부작용 없음

## 플랫폼 요구사항

- iOS 18.0+ / macOS 15.0+ / tvOS 18.0+ / watchOS 11.0+
- Swift 6.0+
- Xcode 16.0+

## 의존성

- `swift-syntax` 602.0.0+ (매크로 구현용)
- `swift-docc-plugin` 1.0.0+ (문서화용)
