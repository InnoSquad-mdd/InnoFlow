// MARK: - InnoFlow.swift (Module Entry Point)
// InnoFlow - A Hybrid Architecture Framework for SwiftUI
// Copyright © 2025 InnoSquad. All rights reserved.

@_exported import Foundation

// MARK: - InnoFlow Macro

/// A macro that generates boilerplate code for InnoFlow features.
///
/// Apply this macro to a struct that defines the core components of a feature:
/// - `State`: The state managed by the feature
/// - `Action`: The actions that can occur
/// - `Mutation`: The state changes (optional - can be auto-generated)
/// - `Effect`: The side effects (optional - defaults to `Never`)
///
/// ## Basic Example
/// ```swift
/// @InnoFlow
/// struct CounterFeature {
///     struct State: Equatable {
///         var count = 0
///     }
///
///     enum Action {
///         case increment
///         case decrement
///     }
///
///     enum Mutation {
///         case setCount(Int)
///     }
///
///     func reduce(state: State, action: Action) -> Reduce<Mutation, Never> {
///         switch action {
///         case .increment:
///             return .mutation(.setCount(state.count + 1))
///         case .decrement:
///             return .mutation(.setCount(state.count - 1))
///         }
///     }
///
///     func mutate(state: inout State, mutation: Mutation) {
///         switch mutation {
///         case .setCount(let value):
///             state.count = value
///         }
///     }
/// }
/// ```
///
/// ## What the Macro Generates
///
/// The `@InnoFlow` macro automatically generates the following:
///
/// 1. **`typealias Effect = Never`** (if `Effect` enum/typealias is not defined)
///    - Added as a member of the struct
///
/// 2. **`extension FeatureName: Reducer`**
///    - Adds conformance to the `Reducer` protocol
///
/// 3. **Default `handle(effect:)` implementation** (if `Effect == Never` and `handle` is not defined)
///    - Provides a default implementation for `Never` effects
///
/// ### Example Expansion
///
/// **Input:**
/// ```swift
/// @InnoFlow
/// struct CounterFeature {
///     struct State: Equatable { var count = 0 }
///     enum Action { case increment }
///     enum Mutation { case setCount(Int) }
///     func reduce(...) -> Reduce<Mutation, Never> { ... }
///     func mutate(...) { ... }
/// }
/// ```
///
/// **Expanded:**
/// ```swift
/// struct CounterFeature {
///     // ... your code ...
///     
///     typealias Effect = Never  // ← Generated by macro
/// }
///
/// extension CounterFeature: Reducer {  // ← Generated by macro
///     func handle(effect: Effect) async -> EffectOutput<Action> {
///         // Never type - unreachable
///     }
/// }
/// ```
///
/// ## With Side Effects
/// ```swift
/// @InnoFlow
/// struct UserFeature {
///     struct State: Equatable {
///         var user: User?
///         var isLoading = false
///     }
///
///     enum Action {
///         case load
///         case _loaded(User?)
///     }
///
///     enum Mutation {
///         case setLoading(Bool)
///         case setUser(User?)
///     }
///
///     enum Effect {
///         case fetchUser
///     }
///
///     let api: APIClient
///
///     func reduce(state: State, action: Action) -> Reduce<Mutation, Effect> {
///         switch action {
///         case .load:
///             return Reduce(
///                 mutations: [.setLoading(true)],
///                 effects: [.fetchUser]
///             )
///         case ._loaded(let user):
///             return .mutations([.setUser(user), .setLoading(false)])
///         }
///     }
///
///     func mutate(state: inout State, mutation: Mutation) {
///         switch mutation {
///         case .setLoading(let value): state.isLoading = value
///         case .setUser(let user): state.user = user
///         }
///     }
///
///     func handle(effect: Effect) async -> EffectOutput<Action> {
///         switch effect {
///         case .fetchUser:
///             let user = try? await api.fetchUser()
///             return .single(._loaded(user))
///         }
///     }
/// }
/// ```
@attached(extension, conformances: Reducer, names: named(Effect), named(handle))
@attached(member, names: named(Effect))
public macro InnoFlow() = #externalMacro(
    module: "InnoFlowMacros",
    type: "InnoFlowMacro"
)

// MARK: - BindableField Macro

/// Marks a State property as intended for two-way binding.
///
/// Properties marked with `@BindableField` are automatically wrapped in `BindableProperty<Value>`.
/// Only these properties can be used with `store.binding(_:send:)`.
///
/// ## Example
/// ```swift
/// struct State: Equatable {
///     @BindableField var name = ""      // Automatically wrapped in BindableProperty<String>
///     @BindableField var step = 1       // Automatically wrapped in BindableProperty<Int>
///     var isLoading = false             // Not bindable - cannot use store.binding
/// }
///
/// // Usage:
/// TextField("Name", text: store.binding(\.name, send: { .nameChanged($0) }))
/// Stepper("Step", value: store.binding(\.step, send: { .setStep($0) }))
/// ```
@attached(accessor)
@attached(peer, names: arbitrary)
public macro BindableField() = #externalMacro(
    module: "InnoFlowMacros",
    type: "BindableFieldMacro"
)
